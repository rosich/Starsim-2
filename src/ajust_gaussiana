subroutine ltt(x,y,sig,nd,a,da,rvmaximum,contrast,fwhm,fitmax)
IMPLICIT REAL*8 (A-H,O-Z)
DIMENSION X(5000),Y(5000),SIG(5000),LISTA(20),COVAR(20,20)
dimension xf(5000),yf(5000)
DIMENSION ALPHA(20,20),A(20),DA(20),YFIT(5000),DYDA(20)
NP=4
ITMAX=10000000
PI=DACOS(-1.D0)
ALAMDA=-0.1D0

gausmx=+1.d30
do i=1,nd
 if(y(i).lt.gausmx) then
  gausmx=y(i)
  rvmx=x(i)
 endif
enddo
do i=1,nd
 if (x(i).gt.rvmx-25.d0) then
 nco=0
 do j=1,nd
  nco=nco+1
  xf(j)=x(i+j-1)
  yf(j)=y(i+j-1)
  if(x(i+j-1).gt.rvmx+25.d0) goto 10
 enddo
 endif
enddo
10   continue

LISTA(4)=1
A(4)=1.d0
LISTA(1)=1
A(1)=gausmx-A(4)
LISTA(2)=1
A(2)=rvmx
LISTA(3)=1
A(3)=5.d0

C      write(*,*) A(1),A(2),A(3),A(4)

xc=XF(1)
90   CALL FUNCSG(xc,A,yc,DYDA,NP) !Evaluate gaussian and its derivatives
xc=xc+0.01d0
If(xc.gt.XF(nco)) Goto 91
Goto 90
91   close(10)

OLDCHISQ=0.D0
ICO=0
Do 15 k=1,ITMAX
CALL MRQMIN(XF,YF,SIG,NCO,A,LISTA,NP,COVAR,ALPHA,20,
$CHISQ,ALAMDA)
IF(DABS(CHISQ-OLDCHISQ).LT.1.D-6) THEN
  ICO=ICO+1
ELSE
  ICO=0
ENDIF
IF(ICO.EQ.5) GOTO 16
OLDCHISQ=CHISQ
68   Format('Reduced Chi square = ',f13.8)
15   Continue
Write(*,*) 'Max. number of iterations exceeded'

16   continue

xc=XF(1)
88   CALL FUNCSG(xc,A,yc,DYDA,NP)
xc=xc+0.01d0
If(xc.gt.XF(nco)) Goto 89
Goto 88
89   close(10)

! Call MRQMIN one final time with ALAMDA=0.0 so that array COVAR will
! return the covariance matrix
CALL MRQMIN(XF,YF,SIG,NCO,A,LISTA,NP,COVAR,ALPHA,20,
$CHISQ,0.D0)


! Uncertainties are derived from the square roots of the diagonal
! elements of COVAR
da(1)=dsqrt(covar(1,1))
da(2)=dsqrt(covar(2,2)) !sig RVmaximum
da(3)=dsqrt(covar(3,3))
da(4)=dsqrt(covar(4,4))

contrast=100.d0*A(1)
rvmaximum=A(2)
FWHM=A(3)
fitmax=A(4)

C      write(*,*) A(1),A(2),A(3),A(4)

return
END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C Repack covariance matrix. This routine repacks the covariance
C matrix COVAR using the order of parameters in IA
C INPUT PARAMETERS:
C       COVAR - input covariance matrix (double precision)
C       NPC - dimensions of COVAR (integer)
C       MA - total number of parameters in fit (integer)
C       IA - list of parameters in fit selected (integer vector)
C       MFIT - number of parameters selected (integer)
C OUTPUT VARIABLES:
C       COVAR - repacked covariance matrix

SUBROUTINE covsrt(covar,npc,ma,ia,mfit)
      INTEGER ma,mfit,npc,ia(ma)
      DOUBLE PRECISION covar(npc,npc)
      INTEGER i,j,k
      DOUBLE PRECISION swap
      do 12 i=mfit+1,ma
        do 11 j=1,i
          covar(i,j)=0.d0
          covar(j,i)=0.d0
11      continue
12    continue
      k=mfit
      do 15 j=ma,1,-1
        if(ia(j).ne.0)then
          do 13 i=1,ma
            swap=covar(i,k)
            covar(i,k)=covar(i,j)
            covar(i,j)=swap
13        continue
          do 14 i=1,ma
            swap=covar(k,i)
            covar(k,i)=covar(j,i)
            covar(j,i)=swap
14        continue
          k=k-1
        endif
15    continue
      return
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C Linear equation solution by Gauss-Jordan elimination
      SUBROUTINE gaussj(a,n,np,b,m,mp)
      INTEGER m,mp,n,np,NMAX
      DOUBLE PRECISION a(np,np),b(np,mp)
      PARAMETER (NMAX=50)
      INTEGER i,icol,irow,j,k,l,ll,indxc(NMAX),indxr(NMAX),ipiv(NMAX)
      DOUBLE PRECISION big,dum,pivinv
      do 11 j=1,n
        ipiv(j)=0
11    continue
      do 22 i=1,n
        big=0.
        do 13 j=1,n
          if(ipiv(j).ne.1)then
            do 12 k=1,n
              if (ipiv(k).eq.0) then
                if (abs(a(j,k)).ge.big)then
                  big=abs(a(j,k))
                  irow=j
                  icol=k
                endif
              else if (ipiv(k).gt.1) then
c               pause 'singular matrix in gaussj'
              endif
12          continue
          endif
13      continue
        ipiv(icol)=ipiv(icol)+1
        if (irow.ne.icol) then
          do 14 l=1,n
            dum=a(irow,l)
            a(irow,l)=a(icol,l)
            a(icol,l)=dum
14        continue
          do 15 l=1,m
            dum=b(irow,l)
            b(irow,l)=b(icol,l)
            b(icol,l)=dum
15        continue
        endif
        indxr(i)=irow
        indxc(i)=icol
c       if (a(icol,icol).eq.0.d0) pause 'singular matrix in gaussj'
        pivinv=1./a(icol,icol)
        a(icol,icol)=1.d0
        do 16 l=1,n
          a(icol,l)=a(icol,l)*pivinv
16      continue
        do 17 l=1,m
          b(icol,l)=b(icol,l)*pivinv
17      continue
        do 21 ll=1,n
          if(ll.ne.icol)then
            dum=a(ll,icol)
            a(ll,icol)=0.d0
            do 18 l=1,n
              a(ll,l)=a(ll,l)-a(icol,l)*dum
18          continue
            do 19 l=1,m
              b(ll,l)=b(ll,l)-b(icol,l)*dum
19          continue
          endif
21      continue
22    continue
      do 24 l=n,1,-1
        if(indxr(l).ne.indxc(l))then
          do 23 k=1,n
            dum=a(k,indxr(l))
            a(k,indxr(l))=a(k,indxc(l))
            a(k,indxc(l))=dum
23        continue
        endif
24    continue
      return
      END

C *******************************************************************
C Levenberg-Marquardt
      SUBROUTINE mrqmin(x,y,sig,ndata,a,ia,ma,covar,alpha,nca,chisq,
     *alamda)
      INTEGER ma,nca,ndata,ia(ma),MMAX
      REAL*8 alamda,chisq,a(ma),alpha(nca,nca),covar(nca,nca),
     *sig(ndata),x(ndata),y(ndata)
      PARAMETER (MMAX=20)
CU    USES covsrt,gaussj,mrqcof
      INTEGER j,k,l,mfit
      REAL*8 ochisq,atry(MMAX),beta(MMAX),da(MMAX)
      SAVE ochisq,atry,beta,da,mfit
      if(alamda.lt.0.D0)then
        mfit=0
        do 11 j=1,ma
          if (ia(j).ne.0) mfit=mfit+1
11      continue
        alamda=0.001D0
        call mrqcof(x,y,sig,ndata,a,ia,ma,alpha,beta,nca,chisq)
        ochisq=chisq
        do 12 j=1,ma
          atry(j)=a(j)
12      continue
      endif
      do 14 j=1,mfit
        do 13 k=1,mfit
          covar(j,k)=alpha(j,k)
13      continue
        covar(j,j)=alpha(j,j)*(1.D0+alamda)
        da(j)=beta(j)
14    continue
      call gaussj(covar,mfit,nca,da,1,1)
      if(alamda.eq.0.D0)then
        call covsrt(covar,nca,ma,ia,mfit)
        return
      endif
      j=0
      do 15 l=1,ma
        if(ia(l).ne.0) then
          j=j+1
          atry(l)=a(l)+da(j)
        endif
15    continue
      call mrqcof(x,y,sig,ndata,atry,ia,ma,covar,da,nca,chisq)
      if(chisq.lt.ochisq)then
        alamda=0.1D0*alamda
        ochisq=chisq
        do 17 j=1,mfit
          do 16 k=1,mfit
            alpha(j,k)=covar(j,k)
16        continue
          beta(j)=da(j)
17      continue
        do 18 l=1,ma
          a(l)=atry(l)
18      continue
      else
        alamda=10.D0*alamda
        chisq=ochisq
      endif
      return
      END

C********************************************************************

      SUBROUTINE mrqcof(x,y,sig,ndata,a,ia,ma,alpha,beta,nalp,chisq)
      INTEGER ma,nalp,ndata,ia(ma),MMAX
      REAL*8 chisq,a(ma),alpha(nalp,nalp),beta(ma),sig(ndata),x(ndata),
     *y(ndata)
      PARAMETER (MMAX=20)
      INTEGER mfit,i,j,k,l,m
      REAL*8 dy,sig2i,wt,ymod,dyda(MMAX),z,xm,xe
      mfit=0
      do 11 j=1,ma
        if (ia(j).ne.0) mfit=mfit+1
11    continue
      do 13 j=1,mfit
        do 12 k=1,j
          alpha(j,k)=0.D0
12      continue
        beta(j)=0.D0
13    continue
      chisq=0.D0
      do 16 i=1,ndata
        call funcsg(x(i),a,ymod,dyda,ma)
        sig2i=1.D0/(sig(i)*sig(i))
        dy=y(i)-ymod
        j=0
        do 15 l=1,ma
          if(ia(l).ne.0) then
            j=j+1
            wt=dyda(l)*sig2i
            k=0
            do 14 m=1,l
              if(ia(m).ne.0) then
                k=k+1
                alpha(j,k)=alpha(j,k)+wt*dyda(m)
              endif
14          continue
            beta(j)=beta(j)+dy*wt
          endif
15      continue
        chisq=chisq+dy*dy*sig2i
16    continue
      do 18 j=2,mfit
        do 17 k=1,j-1
          alpha(k,j)=alpha(j,k)
17      continue
18    continue
      return
      END

C********************************************************************
C Evaluate gaussian and derivatives
    
  SUBROUTINE FUNCSG(X,A,Y,DYDA,NA)

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION A(NA),DYDA(NA)

      Y=A(4)+A(1)*dexp(-(X-A(2))**2.d0/A(3)) !gaussian

      DYDA(1)=dexp(-(X-A(2))**2.d0/A(3))

      DYDA(2)=2.d0*((X-A(2))/A(3))*A(1)*dexp(-(X-A(2))**2.d0/A(3))

      DYDA(3)=(((X-A(2))/A(3))**2.d0)*A(1)*dexp(-(X-A(2))**2.d0/A(3))

      DYDA(4)=1.d0

      RETURN
      END
C********************************************************************